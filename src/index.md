# boldandbrad docs

> [!note]
> These docs are both opinionated and a work in progress. Use at your own risk.

Hi ðŸ‘‹, my name is **boldandbrad** and this is my personal documentation site. It
contains an incomplete record of my learnings as a software developer, as well
as my thoughts and notes on various other topics. I've made it open source to
make it easy to access and to serve as an example for others.

My intent is to regularly update this site as I learn and explore new topics,
tools, and techniques. Since I am always trying to learn, feel free to
[submit an issue](https://github.com/boldandbrad/docs/issues) or a pull request
if you find a problem or have something cool to share with me. However, since
this knowledge base is largely for personal use, please understand that I may
choose to reject them.

I have made an attempt to link additional relevant resources and to site sources
where possible, though the effort is incomplete.

## Principles

I believe in the [beginner mindset](https://en.wikipedia.org/wiki/Shoshin). As a
result, I do not claim to be an expert in any of the topics covered on this
site. Rather than aiming for perfect guidance, I prioritize documenting topics
that I find myself referencing often or wanting to remember. At a minimum, I
hope to:

- Keep it **simple**,
- Remain **consistent**,
- and Explain **why**.

## Patterns

Just a list of things I care about for now...

- Readme Driven Development (RDD)
- Semantic Versioning (SemVer)
- Keep a Changelog
- Agile Principles
- Open Source
- Environmentally concious solutions

## Stack

At the rate that new frameworks, technologies, and design patterns are created,
it is impossible and also nonsensical to maintain a static tech stack. However,
in an effort to create some semblance of consistency and to prevent endless
context switching, I do tend to fallback on a common set of technologies for
projects that I maintain.

Generally speaking, I try to strike a balance between using the best tool for
the job, and using multi-purpose tools. That is, if the best tool for a
particular use case doesn't play well with the rest of my stack/knowledge base,
but the 2nd or 3rd best tool does, I opt for one of those.

For this reason, you'll find that I try to choose tools and patterns that are
applicable in multiple domains.

### Preferred Languages

I tend to prefer working in compiled languages with strong type safety.

- [Rust](https://www.rust-lang.org/) - A type-safe, memory safe, and performant
  general purpose language.
- [Go](https://go.dev/) - A type-safe, concurrency friendly language with a
  strong standard library.
- [TypeScript](https://www.typescriptlang.org/) via [Deno](https://deno.land/) -
  A type-safe superset of JavaScript.

The following are languages I've learned and used in the past but do not favor
today:

- [JavaScript](https://www.javascript.com/) via [Node](https://nodejs.org/)
- [Java](https://www.java.com/)
- [Python](https://www.python.org/)

### Tooling

- GitHub
- Git - Version control
- Neovim - Text editor
- Vscodium - Text editor

---

Copyright Â© 2020-present Bradley Wojcik. Powered by
  [Lume](https://lume.land/).
